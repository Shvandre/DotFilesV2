{"version":3,"file":"static/js/134.88af47eb.chunk.js","mappings":"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","sources":["libs/entries/asset.ts","libs/entries/wallet.ts","libs/service/requestService.ts","libs/service/transfer/core.ts","libs/service/transfer/jettonService.ts","libs/service/transfer/nftService.ts","libs/service/transfer/payload.ts","libs/service/transfer/restrictionService.ts","libs/service/transfer/tonService.ts","libs/state/assetService.ts","libs/state/decimalsService.ts","libs/state/jettonService.ts","view/FingerprintLabel.tsx","view/components/Address.tsx","view/components/AddressBlock.tsx","view/components/CodeBlock.tsx","view/components/JettonRow.tsx","view/components/NftPayload.tsx","view/components/send/Fees.tsx","view/hooks/useTimeout.ts","view/hooks/useCopyToClipbpard.ts","view/screen/home/wallet/assets/import/api.ts","view/screen/home/wallet/send/api.ts"],"sourcesContent":["import Joi from \"joi\";\nimport { JettonMinterContent } from \"ton-wrappers\";\n\nexport interface JettonParams {\n  type: \"jetton\";\n  // The address of the minter contract\n  address: string;\n  // A ticker symbol or shorthand, up to 11 characters\n  symbol?: string;\n  // A string url of the token logo\n  image?: string;\n  // A jetton name\n  name?: string;\n  // A jetton decimals\n  decimals?: string;\n}\n\nexport const JettonParamsSchema = Joi.object<JettonParams>({\n  type: Joi.string().required().valid(\"jetton\"),\n  address: Joi.string().required(),\n  symbol: Joi.string(),\n  image: Joi.string(),\n  name: Joi.string(),\n  decimals: Joi.string(),\n});\n\nexport interface NftParams {\n  type: \"nft\";\n  // The address of the nft contract\n  address: string;\n}\n\nexport const NftParamsSchema = Joi.object<NftParams>({\n  type: Joi.string().required().valid(\"nft\"),\n  address: Joi.string().required(),\n});\n\nexport type AssetParams = JettonParams | NftParams;\n\nexport const JettonStateSchema = Joi.object<JettonMinterContent>({\n  name: Joi.string().required(),\n  symbol: Joi.string().required(),\n  description: Joi.string(),\n  image: Joi.string(),\n  decimals: Joi.string(),\n}).unknown();\n\nexport interface JettonAsset {\n  state: JettonMinterContent;\n  minterAddress: string;\n  walletAddress?: string;\n}\n\nexport type NftItemState = ImageNftState | DomainNftState;\n\nexport interface ImageNftState {\n  image: string;\n  name?: string;\n  description?: string;\n}\n\nexport interface DomainNftState {\n  name?: string;\n  root: string;\n  domain: string;\n}\n\nexport const NftItemStateSchema = Joi.object<NftItemState>({\n  image: Joi.string().required(),\n  name: Joi.string(),\n  description: Joi.string(),\n}).unknown();\n\nexport interface NftItem {\n  state: NftItemState | null;\n  contentUri: string | null;\n  address: string;\n}\n\nexport interface NftCollectionState {\n  image: string;\n  name?: string;\n  description?: string;\n}\n\nexport const NftCollectionStateSchema = Joi.object<NftCollectionState>({\n  image: Joi.string().required(),\n  name: Joi.string(),\n  description: Joi.string(),\n}).unknown();\n\nexport interface NftAsset {\n  items: NftItem[];\n  state: NftCollectionState | null;\n  collectionAddress: string;\n}\n\nexport type Asset = JettonAsset | NftAsset;\n","import { Asset } from \"./asset\";\n\nexport type WalletVersion = \"v2R1\" | \"v2R2\" | \"v3R1\" | \"v3R2\" | \"v4R1\" | \"v4R2\";\n\nexport type LedgerDriver = \"USB\" | \"HID\";\n\nexport interface LedgerState {\n  index: number;\n  driver: LedgerDriver;\n  productId?: string;\n  productName?: string;\n}\n\nexport interface WalletState {\n  name: string;\n  mnemonic: string;\n  address: string;\n  publicKey: string;\n  version: WalletVersion;\n  isBounceable: boolean;\n\n  /**\n   * @deprecated use walletAssets\n   */\n  assets?: Asset[];\n  walletAssets?: Record<WalletVersion, Asset[]>;\n\n  ledger?: LedgerState;\n}\n\nexport const getWalletAssets = (wallet: WalletState): Asset[] => {\n  let assets: Asset[];\n  if (wallet.walletAssets && wallet.walletAssets[wallet.version]) {\n    assets = wallet.walletAssets[wallet.version];\n  } else {\n    assets = wallet.assets ?? [];\n  }\n\n  // null-byte in address\n  return assets.map((item) => {\n    if (\"minterAddress\" in item) {\n      return { ...item, minterAddress: item.minterAddress.replace(/\\0/g, \"\") };\n    } else {\n      return {\n        ...item,\n        items: item.items.map((nft) => ({\n          ...nft,\n          address: nft.address.replace(/\\0/g, \"\"),\n        })),\n      };\n    }\n  });\n};\n\nexport const setWalletAssets = (wallet: WalletState, newAssets: Asset[]) => {\n  let { assets, walletAssets, ...rest } = wallet;\n  walletAssets = walletAssets ?? ({} as Record<WalletVersion, Asset[]>);\n  walletAssets[wallet.version] = newAssets;\n  return { ...rest, walletAssets };\n};\n\nexport interface WalletInfo {\n  account_state: string;\n  balance: string;\n  last_transaction_id: {\n    [\"@type\"]: string;\n    hash: string;\n    lt: string;\n  };\n  seqno: number;\n  wallet: boolean;\n  wallet_id: number;\n  wallet_type: string;\n}\n","const ifpsProtocol = \"ipfs://\";\n\nexport const ipfsProxy = (url: string) => {\n    if (url === \"https://raw.githubusercontent.com/catchain/metadata/refs/heads/main/ion/staking/logo.png\") {\n        url = \"https://raw.githubusercontent.com/ice-blockchain/wallets-list/refs/heads/master/lion-square-rounded.svg\";\n    }\n    if (url.startsWith(ifpsProtocol)) {\n        return url.replace(ifpsProtocol, \"https://ipfs.io/ipfs/\");\n    }\n    return url;\n};\n","import {\n  Address,\n  Cell,\n  Contract,\n  ContractProvider,\n  beginCell,\n  storeStateInit,\n} from \"@ton/core\";\nimport {\n  WalletContractV2R1,\n  WalletContractV2R2,\n  WalletContractV3R1,\n  WalletContractV3R2,\n  WalletContractV4,\n} from \"@ton/ton\";\nimport { WalletState } from \"../../entries/wallet\";\n\nconst workchain = 0;\n\nexport const getWalletContract = (wallet: WalletState) => {\n  const publicKey = Buffer.from(wallet.publicKey, \"hex\");\n  switch (wallet.version) {\n    case \"v2R1\":\n      return WalletContractV2R1.create({ workchain, publicKey });\n    case \"v2R2\":\n      return WalletContractV2R2.create({ workchain, publicKey });\n    case \"v3R1\":\n      return WalletContractV3R1.create({ workchain, publicKey });\n    case \"v3R2\":\n      return WalletContractV3R2.create({ workchain, publicKey });\n    case \"v4R1\":\n      throw new Error(\"Unsupported wallet contract version - v4R1\");\n    case \"v4R2\":\n      return WalletContractV4.create({ workchain, publicKey });\n  }\n};\n\nexport function getContractAddress(source: {\n  workchain: number;\n  code: Cell;\n  data: Cell;\n}) {\n  const cell = beginCell()\n    .storeWritable(storeStateInit({ code: source.code, data: source.data }))\n    .endCell();\n  return new Address(source.workchain, cell.hash());\n}\n\nexport const getWalletAddress = (wallet: WalletState, network: string) => {\n  const contract = getWalletContract(wallet);\n  const address = getContractAddress({\n    workchain: contract.workchain,\n    code: contract.init.code,\n    data: contract.init.data,\n  });\n  return address.toString({\n    urlSafe: true,\n    bounceable: wallet.isBounceable,\n    testOnly: network === \"testnet\",\n  });\n};\n\nexport class AnyWallet implements Contract {\n  constructor(\n    readonly address: Address,\n    readonly init?: { code: Cell; data: Cell }\n  ) {}\n\n  static createFromAddress(address: Address) {\n    return new AnyWallet(address);\n  }\n\n  async getSeqno(provider: ContractProvider): Promise<number> {\n    let state = await provider.getState();\n    if (state.state.type === \"active\") {\n      let res = await provider.get(\"seqno\", []);\n      return res.stack.readNumber();\n    } else {\n      return 0;\n    }\n  }\n\n  async getPublicKey(provider: ContractProvider): Promise<string> {\n    let state = await provider.getState();\n\n    if (state.state.type !== \"active\") {\n      throw new Error(`Wallet is not deployed: ${state.state.type}`);\n    }\n\n    const res = await provider.get(\"get_public_key\", []);\n    const walletPubKeyBN = res.stack.readBigNumber();\n    let walletPubKeyHex = walletPubKeyBN.toString(16);\n    if (walletPubKeyHex.length % 2 !== 0) {\n      walletPubKeyHex = \"0\" + walletPubKeyHex;\n    }\n    return walletPubKeyHex;\n  }\n}\n","import { TonPayloadFormat } from \"@ton-community/ton-ledger\";\nimport {\n  Address,\n  beginCell,\n  Builder,\n  Cell,\n  internal,\n  SendMode,\n  toNano,\n} from \"@ton/core\";\nimport BigNumber from \"bignumber.js\";\nimport { JettonAsset } from \"../../entries/asset\";\nimport { WalletState } from \"../../entries/wallet\";\nimport { getWalletContract } from \"./core\";\nimport { LedgerTransfer } from \"./ledger\";\n\nexport interface SendJettonState {\n  /**\n   * The Jetton receiver main wallet address.\n   */\n  address: string;\n  /**\n   * Amount of jettons to transfer\n   */\n  amount: string;\n\n  /**\n   * ION Amount with would be transfer to handle internal transaction expenses\n   * By default community agreed to 0.1 ION\n   */\n  transactionAmount: string;\n\n  /**\n   * The amount of ton from `transactionAmount` with would be sent to the jetton receiver to notify it.\n   * The value should be less then `transactionAmount`.\n   * default - 0.000000001\n   */\n  forwardAmount?: string;\n\n  /**\n   * The forward comment with should show to jetton receiver with `forwardAmount`\n   * I can't send transaction to receiver have a forwarded message,\n   * if some one have an idea how wrap the text, I will appreciate for help\n   */\n  comment: string;\n}\n\nconst DefaultDecimals = 9;\n\nconst jettonTransferForwardAmount = toNano(\"0.0001\");\n\nexport const JettonTransferOpCode = 0xf8a7ea5;\n\nconst jettonTransferBody = (params: {\n  queryId?: number;\n  jettonAmount: bigint;\n  toAddress: Address;\n  responseAddress: Address;\n  forwardAmount: bigint;\n  forwardPayload: Builder | null;\n}) => {\n  return beginCell()\n    .storeUint(0xf8a7ea5, 32) // request_transfer op\n    .storeUint(params.queryId || 0, 64)\n    .storeCoins(params.jettonAmount)\n    .storeAddress(params.toAddress)\n    .storeAddress(params.responseAddress)\n    .storeBit(false) // null custom_payload\n    .storeCoins(params.forwardAmount)\n    .storeBit(false) // forward_payload in this slice, not separate cell\n    .storeMaybeBuilder(params.forwardPayload)\n    .endCell();\n};\n\nexport const parseJettonTransfer = (data: Cell): TonPayloadFormat => {\n  const slice = data.asSlice();\n\n  const operation = slice.loadUint(32);\n  if (operation != JettonTransferOpCode) {\n    throw new Error(\"Invalid operator\");\n  }\n\n  const queryId = slice.loadUint(64);\n  const jettonAmount = slice.loadCoins();\n  const toAddress = slice.loadMaybeAddress();\n  const responseAddress = slice.loadMaybeAddress();\n  const isCustomPayload = slice.loadBit();\n  const customPayload = isCustomPayload ? slice.loadRef() : null;\n  const forwardAmount = slice.loadCoins();\n  const isForwardPayload = slice.loadBit();\n  const forwardPayload = isForwardPayload\n    ? slice.loadRef()\n    : slice.remainingBits > 0\n    ? slice.asCell()\n    : null;\n\n  return {\n    type: \"jetton-transfer\",\n    queryId: BigInt(queryId),\n    amount: jettonAmount,\n    destination: toAddress!,\n    responseDestination: responseAddress!,\n    customPayload: customPayload,\n    forwardAmount: forwardAmount,\n    forwardPayload: forwardPayload,\n  };\n};\n\nconst getJettonAmount = (data: SendJettonState, jetton: JettonAsset) => {\n  const decimals = jetton.state.decimals\n    ? parseInt(String(jetton.state.decimals))\n    : DefaultDecimals;\n\n  return BigInt(\n    new BigNumber(data.amount)\n      .shiftedBy(decimals)\n      .toFormat({ decimalSeparator: \".\", groupSeparator: \"\" })\n  );\n};\n\nexport const createJettonTransfer = (\n  seqno: number,\n  walletState: WalletState,\n  recipientAddress: string,\n  jettonWalletAddress: Address,\n  data: SendJettonState,\n  jetton: JettonAsset,\n  secretKey: Buffer = Buffer.alloc(64)\n) => {\n  const body = jettonTransferBody({\n    queryId: Date.now(),\n    jettonAmount: getJettonAmount(data, jetton),\n    toAddress: Address.parse(recipientAddress),\n    responseAddress: Address.parse(walletState.address),\n    forwardAmount: jettonTransferForwardAmount,\n    forwardPayload: null,\n  });\n\n  const contract = getWalletContract(walletState);\n  const transfer = contract.createTransfer({\n    seqno,\n    secretKey,\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n    messages: [\n      internal({\n        to: jettonWalletAddress,\n        bounce: true,\n        value: toNano(data.transactionAmount),\n        body,\n      }),\n    ],\n  });\n\n  return transfer;\n};\n\nexport const createLedgerJettonTransfer = (\n  wallet: WalletState,\n  seqno: number,\n  recipientAddress: string,\n  jettonWalletAddress: Address,\n  data: SendJettonState,\n  jetton: JettonAsset\n): LedgerTransfer => {\n  const walletContract = getWalletContract(wallet);\n\n  return createLedgerJettonTransferPayload(\n    jettonWalletAddress,\n    toNano(data.transactionAmount),\n    seqno,\n    walletContract.init,\n    {\n      type: \"jetton-transfer\",\n      queryId: BigInt(Date.now()),\n      amount: getJettonAmount(data, jetton),\n      destination: Address.parse(recipientAddress),\n      responseDestination: Address.parse(wallet.address),\n      customPayload: null,\n      forwardAmount: jettonTransferForwardAmount,\n      forwardPayload: null,\n    }\n  );\n};\n\nexport const createLedgerJettonTransferPayload = (\n  address: Address,\n  amount: bigint,\n  seqno: number,\n  stateInit: { data: Cell; code: Cell },\n  payload: TonPayloadFormat\n): LedgerTransfer => {\n  const transaction = {\n    to: address,\n    amount: amount,\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n    seqno,\n    timeout: Math.floor(Date.now() / 1000 + 60),\n    bounce: true,\n    stateInit: stateInit,\n    payload,\n  };\n  return transaction;\n};\n","import { TonPayloadFormat } from \"@ton-community/ton-ledger\";\nimport {\n  Address,\n  beginCell,\n  Builder,\n  Cell,\n  internal,\n  SendMode,\n  toNano,\n} from \"@ton/core\";\nimport { NftItem } from \"../../entries/asset\";\nimport { WalletState } from \"../../entries/wallet\";\nimport { getWalletContract } from \"./core\";\nimport { LedgerTransfer } from \"./ledger\";\n\nexport interface SendNftState {\n  /**\n   * The nft receiver wallet address.\n   */\n  address: string;\n  /**\n   * The amount of ton to cover transaction and storage cost.\n   * default - 0.05\n   */\n  amount: string;\n  /**\n   * The amount of ton from `amount` with would be sent to the nft receiver to notify it.\n   * The value should be less then `amount`.\n   * default - 0.000000001\n   */\n  forwardAmount: string;\n\n  /**\n   * The forward comment with should show to nft receiver with `forwardAmount`\n   * I can't send transaction to receiver have a forwarded message,\n   * if some one have an idea how wrap the text, I will appreciate for help\n   */\n  comment: string;\n}\n\nexport const NftTransferOpCode = 0x5fcc3d14;\n\nconst nftTransferBody = (params: {\n  queryId?: number;\n  newOwnerAddress: Address;\n  responseAddress: Address;\n  forwardAmount: bigint;\n  forwardPayload: Builder | null;\n}) => {\n  return beginCell()\n    .storeUint(0x5fcc3d14, 32) // transfer op\n    .storeUint(params.queryId || 0, 64)\n    .storeAddress(params.newOwnerAddress)\n    .storeAddress(params.responseAddress)\n    .storeBit(false) // null custom_payload\n    .storeCoins(params.forwardAmount)\n    .storeBit(false) // forward_payload in this slice, not separate cell\n    .storeMaybeBuilder(params.forwardPayload)\n    .endCell();\n};\n\nexport const parseNftTransfer = (data: Cell): TonPayloadFormat => {\n  const slice = data.asSlice();\n\n  const operation = slice.loadUint(32);\n  if (operation != NftTransferOpCode) {\n    throw new Error(\"Invalid operator\");\n  }\n\n  const queryId = slice.loadUint(64);\n  const newOwnerAddress = slice.loadMaybeAddress();\n  const responseAddress = slice.loadMaybeAddress();\n  const isCustomPayload = slice.loadBit();\n  const customPayload = isCustomPayload ? slice.loadRef() : null;\n  const forwardAmount = slice.loadCoins();\n  const isForwardPayload = slice.loadBit();\n  const forwardPayload = isForwardPayload\n    ? slice.loadRef()\n    : slice.remainingBits > 0\n    ? slice.asCell()\n    : null;\n\n  return {\n    type: \"nft-transfer\",\n    queryId: BigInt(queryId),\n    newOwner: newOwnerAddress!,\n    responseDestination: responseAddress!,\n    customPayload: customPayload,\n    forwardAmount: forwardAmount,\n    forwardPayload: forwardPayload,\n  };\n};\n\nexport const createNftTransfer = (\n  seqno: number,\n  walletState: WalletState,\n  recipientAddress: string,\n  state: SendNftState,\n  nft: NftItem,\n  secretKey: Buffer = Buffer.alloc(64)\n) => {\n  const body = nftTransferBody({\n    queryId: Date.now(),\n    newOwnerAddress: Address.parse(recipientAddress),\n    responseAddress: Address.parse(walletState.address),\n    forwardAmount: toNano(state.forwardAmount),\n    forwardPayload: null,\n  });\n\n  const contract = getWalletContract(walletState);\n  const transfer = contract.createTransfer({\n    seqno,\n    secretKey,\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n    messages: [\n      internal({\n        to: Address.parse(nft.address),\n        bounce: true,\n        value: toNano(state.amount),\n        body,\n      }),\n    ],\n  });\n\n  return transfer;\n};\n\nexport const createLedgerNftTransfer = (\n  wallet: WalletState,\n  seqno: number,\n  recipientAddress: string,\n  state: SendNftState,\n  nft: NftItem\n): LedgerTransfer => {\n  const walletContract = getWalletContract(wallet);\n\n  return createLedgerNftTransferPayload(\n    nft.address,\n    toNano(state.amount),\n    seqno,\n    walletContract.init,\n    {\n      type: \"nft-transfer\",\n      queryId: BigInt(Date.now()),\n      newOwner: Address.parse(recipientAddress),\n      responseDestination: Address.parse(wallet.address),\n      customPayload: null,\n      forwardAmount: toNano(state.forwardAmount),\n      forwardPayload: null,\n    }\n  );\n};\n\nexport const createLedgerNftTransferPayload = (\n  address: string,\n  amount: bigint,\n  seqno: number,\n  stateInit: { data: Cell; code: Cell },\n  payload: TonPayloadFormat\n): LedgerTransfer => {\n  const transaction = {\n    to: Address.parse(address),\n    amount: amount,\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n    seqno,\n    timeout: Math.floor(Date.now() / 1000 + 60),\n    bounce: true,\n    stateInit,\n    payload: payload,\n  };\n  return transaction;\n};\n","import { getSharedSecret } from \"@noble/ed25519\";\nimport { Address, beginCell, Builder, Cell } from \"@ton/core\";\nimport { TonClient } from \"@ton/ton\";\nimport nacl, { randomBytes } from \"tweetnacl\";\nimport { AnyWallet } from \"./core\";\n\nexport const getWalletPublicKey = async (\n  tonClient: TonClient,\n  address: string\n): Promise<string> => {\n  const contract = tonClient.open(\n    AnyWallet.createFromAddress(Address.parse(address))\n  );\n  return await contract.getPublicKey();\n};\n\nfunction writeBuffer(src: Buffer, builder: Builder) {\n  if (src.length > 0) {\n    let bytes = Math.floor(builder.availableBits / 8);\n    if (src.length > bytes) {\n      let a = src.subarray(0, bytes);\n      let t = src.subarray(bytes);\n      builder = builder.storeBuffer(a);\n      let bb = beginCell();\n      writeBuffer(t, bb);\n      builder = builder.storeRef(bb.endCell());\n    } else {\n      builder = builder.storeBuffer(src);\n    }\n  }\n}\n\nconst encryptedComment = (data: string, sharedKey: Uint8Array) => {\n  const nonce = randomBytes(nacl.box.nonceLength);\n  const encrypted = nacl.box.after(\n    new TextEncoder().encode(data),\n    nonce,\n    sharedKey\n  );\n\n  if (!encrypted) {\n    throw new Error(\"Encryption error\");\n  }\n  const payload = Buffer.concat([nonce, encrypted]);\n\n  let builder = beginCell().storeUint(1, 32);\n  writeBuffer(payload, builder);\n  return builder.endCell();\n};\n\nexport const getEstimatePayload = async (\n  tonClient: TonClient,\n  address: string,\n  isEncrypt: boolean | undefined,\n  data: string | Cell | undefined\n): Promise<string | Cell | undefined> => {\n  if (data === undefined || data === \"\") {\n    return undefined;\n  }\n  if (!isEncrypt || typeof data !== \"string\") {\n    return data;\n  }\n\n  const receiverPublicKey = await getWalletPublicKey(tonClient, address);\n  const sharedKey = await getSharedSecret(\n    Buffer.alloc(32).toString(\"hex\"),\n    receiverPublicKey\n  );\n  return encryptedComment(data, sharedKey);\n};\n\nexport const getPayload = async (\n  tonClient: TonClient,\n  address: string,\n  isEncrypt: boolean | undefined,\n  data: string | Cell | undefined,\n  secretKey: Buffer = Buffer.alloc(32)\n): Promise<string | Cell | undefined> => {\n  if (data === undefined || data === \"\") {\n    return undefined;\n  }\n  if (!isEncrypt || typeof data !== \"string\") {\n    return data;\n  }\n\n  const receiverPublicKey = await getWalletPublicKey(tonClient, address);\n  const sharedKey = await getSharedSecret(\n    secretKey.subarray(0, 32).toString(\"hex\"),\n    receiverPublicKey\n  );\n  return encryptedComment(data, sharedKey);\n};\n","import { Address } from \"@ton/core\";\nimport { TonConnectTransactionPayloadMessage } from \"../../entries/notificationMessage\";\nimport {\n  QueryType,\n  getCachedStoreValue,\n  setCachedStoreValue,\n} from \"../../store/browserStore\";\n\nexport interface Restrictions {\n  origin: string[];\n  address: string[];\n}\n\nexport const getRestrictions = async () => {\n  try {\n    let data = await getCachedStoreValue<Restrictions>(QueryType.restriction);\n\n    if (!data) {\n      const response = await fetch(\n        \"https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/resources/restrictions.json\"\n      );\n\n      if (response.status !== 200) {\n        throw new Error(response.statusText);\n      }\n      data = (await response.json()) as Restrictions;\n      await setCachedStoreValue(QueryType.restriction, data);\n    }\n\n    return data;\n  } catch (e) {\n    console.log(e);\n    return { origin: [], address: [] };\n  }\n};\n\nexport const validateAddressRestrictions = async (address: string) => {\n  const restrictions = await getRestrictions();\n\n  restrictions.address.forEach((a) => {\n    if (Address.parse(a).equals(Address.parse(address))) {\n      throw new Error(`Address ${a} restricted`);\n    }\n  });\n};\n\nexport const validateTonConnectRestrictions = async (\n  origin: string,\n  state: TonConnectTransactionPayloadMessage[]\n) => {\n  const restrictions = await getRestrictions();\n\n  restrictions.origin.forEach((o) => {\n    if (o === origin) {\n      throw new Error(`Origin ${o} restricted`);\n    }\n  });\n\n  state.forEach((item) => {\n    restrictions.address.forEach((a) => {\n      if (Address.parse(a).equals(Address.parse(item.address))) {\n        throw new Error(`Address ${a} restricted`);\n      }\n    });\n  });\n};\n","import { TonPayloadFormat } from \"@ton-community/ton-ledger\";\nimport { Address, Cell, fromNano, internal, SendMode, toNano } from \"@ton/core\";\nimport { TonConnectTransactionPayloadMessage } from \"../../entries/notificationMessage\";\nimport { WalletState } from \"../../entries/wallet\";\nimport { getWalletContract } from \"./core\";\nimport { LedgerTransfer } from \"./ledger\";\n\nexport interface AmountValue {\n  max?: string;\n  amount: string;\n}\n\nexport interface TransactionState extends AmountValue {\n  address: string;\n  data: string | Cell | undefined;\n  hex?: string;\n  isEncrypt?: boolean;\n}\n\nexport interface InitData {\n  code?: Cell;\n  data?: Cell;\n}\n\nexport const getTonSendMode = (max: string | undefined) => {\n  return max === \"1\"\n    ? SendMode.CARRY_ALL_REMAINING_BALANCE\n    : SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS;\n};\n\nconst seeIfBounceable = (address: string) => {\n  return Address.isFriendly(address)\n    ? Address.parseFriendly(address).isBounceable\n    : false;\n};\n\nexport const createTonTransfer = (\n  seqno: number,\n  walletState: WalletState,\n  address: string,\n  data: AmountValue,\n  comment: Cell | string | undefined,\n  init?: InitData,\n  secretKey: Buffer = Buffer.alloc(64)\n) => {\n  const contract = getWalletContract(walletState);\n  const transfer = contract.createTransfer({\n    seqno,\n    secretKey,\n    sendMode: getTonSendMode(data.max),\n    messages: [\n      internal({\n        to: address,\n        bounce: seeIfBounceable(address),\n        value: toNano(data.amount),\n        init,\n        body: comment,\n      }),\n    ],\n  });\n\n  return transfer;\n};\n\nexport const toStateInit = (stateInit?: string): InitData | undefined => {\n  if (!stateInit) {\n    return undefined;\n  }\n\n  const initSlice = Cell.fromBase64(stateInit).asSlice();\n  return {\n    code: initSlice.loadRef(),\n    data: initSlice.loadRef(),\n  };\n};\n\nexport const createTonConnectTransfer = (\n  wallet: WalletState,\n  seqno: number,\n  state: TonConnectTransactionPayloadMessage[],\n  secretKey: Buffer = Buffer.alloc(64)\n) => {\n  const walletContract = getWalletContract(wallet);\n\n  const transfer = walletContract.createTransfer({\n    secretKey,\n    seqno,\n    sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n    messages: state.map((item) => {\n      return internal({\n        to: item.address,\n        value: toNano(fromNano(item.amount)),\n        bounce: seeIfBounceable(item.address),\n        init: toStateInit(item.stateInit),\n        body: item.payload ? Cell.fromBase64(item.payload) : undefined,\n      });\n    }),\n  });\n\n  return transfer;\n};\n\nexport const createLedgerTonTransfer = (\n  wallet: WalletState,\n  seqno: number,\n  address: string,\n  state: AmountValue,\n  body: Cell | string | undefined\n): LedgerTransfer => {\n  const walletContract = getWalletContract(wallet);\n\n  const payload: TonPayloadFormat | undefined = (() => {\n    if (body === undefined) {\n      return undefined;\n    }\n    if (typeof body === \"string\") {\n      return { type: \"comment\", text: body };\n    }\n\n    throw new Error(\"Complex transaction is not supported\");\n  })();\n\n  const transaction = {\n    to: Address.parse(address),\n    amount: toNano(state.amount),\n    sendMode: getTonSendMode(state.max),\n    seqno,\n    timeout: Math.floor(Date.now() / 1000 + 60),\n    bounce: seeIfBounceable(address),\n    stateInit: walletContract.init,\n    payload,\n  };\n\n  return transaction;\n};\n","/**\n * Service methods to manage asset state for application\n * The file should contain pure function to mutate state\n *\n * @author: KuznetsovNikita\n * @since: 0.8.0\n */\n\nimport { NftData } from \"@openproduct/web-sdk\";\nimport { JettonMinterContent } from \"ton-wrappers\";\nimport { AccountState } from \"../entries/account\";\nimport {\n  Asset,\n  JettonAsset,\n  NftAsset,\n  NftCollectionState,\n  NftItem,\n  NftItemState,\n} from \"../entries/asset\";\nimport { getWalletAssets, setWalletAssets } from \"../entries/wallet\";\n\nexport interface JettonWalletData {\n  balance: string;\n  address: string;\n}\n\nexport interface AddJettonProps {\n  minter: string;\n  jettonState: JettonMinterContent;\n  jettonWallet: JettonWalletData | null;\n}\n\nexport const seeIfJettonAsset = (asset: Asset): asset is JettonAsset => {\n  return \"minterAddress\" in asset;\n};\n\nconst useActiveAssets = (\n  account: AccountState,\n  map: (assets: Asset[]) => Asset[]\n): AccountState => {\n  return {\n    ...account,\n    wallets: account.wallets.map((wallet) => {\n      if (wallet.address === account.activeWallet) {\n        return setWalletAssets(wallet, map(getWalletAssets(wallet)));\n      }\n      return wallet;\n    }),\n  };\n};\n\nexport const addJettonToWallet = (\n  account: AccountState,\n  { minter, jettonState, jettonWallet }: AddJettonProps\n): AccountState => {\n  return useActiveAssets(account, (assets) => {\n    if (\n      !assets.some(\n        (item) => seeIfJettonAsset(item) && item.minterAddress === minter\n      )\n    ) {\n      // If not exists\n      const asset: JettonAsset = {\n        state: jettonState,\n        minterAddress: minter,\n        walletAddress: jettonWallet?.address,\n      };\n      return assets.concat([asset]);\n    }\n    return assets;\n  });\n};\n\nexport const deleteJettonAsset = (\n  account: AccountState,\n  jettonMinterAddress: string\n): AccountState => {\n  return useActiveAssets(account, (assets) => {\n    return assets.filter((asset) => {\n      if (!seeIfJettonAsset(asset)) {\n        return true;\n      } else {\n        return asset.minterAddress !== jettonMinterAddress;\n      }\n    });\n  });\n};\n\nconst setIfNftAssetOver = (collectionAddress: string) => {\n  return (value: Asset): value is NftAsset => {\n    return (\n      !seeIfJettonAsset(value) && value.collectionAddress === collectionAddress\n    );\n  };\n};\n\nexport interface AddNftProps {\n  nftAddress: string;\n  nftData: NftData;\n  state: NftItemState | null;\n  collection: NftCollectionState | null;\n}\n\nexport const addNftToWallet = (\n  account: AccountState,\n  { nftAddress, nftData, state, collection }: AddNftProps\n): AccountState => {\n  const nftItemState: NftItem = {\n    state: state,\n    contentUri: nftData.contentUri,\n    address: nftAddress,\n  };\n  const collectionAddress = nftData.collectionAddress\n    ? nftData.collectionAddress.toString(true, true, true)\n    : nftAddress;\n\n  return useActiveAssets(account, (assets) => {\n    const collectionAsset = assets.find<NftAsset>(\n      setIfNftAssetOver(collectionAddress)\n    );\n\n    if (collectionAsset && !seeIfJettonAsset(collectionAsset)) {\n      if (!collectionAsset.items.some((item) => item.address === nftAddress)) {\n        // If not exists\n        collectionAsset.items.push(nftItemState);\n      }\n    } else {\n      const asset: NftAsset = {\n        collectionAddress,\n        state: collection,\n        items: [nftItemState],\n      };\n\n      assets.push(asset);\n    }\n    return assets;\n  });\n};\n\nexport interface DeleteNftProps {\n  collectionAddress: string;\n  address: string;\n}\n\nexport const deleteNftAsset = (\n  account: AccountState,\n  { collectionAddress, address }: DeleteNftProps\n): AccountState => {\n  return useActiveAssets(account, (assets) => {\n    const collectionAsset = assets.find<NftAsset>(\n      setIfNftAssetOver(collectionAddress)\n    );\n    if (!collectionAsset) {\n      return assets;\n    }\n\n    if (collectionAsset.items.length === 1) {\n      return assets.filter((item) => item != collectionAsset);\n    } else {\n      return assets.map((asset) => {\n        if (asset !== collectionAsset) {\n          return asset;\n        } else {\n          return {\n            ...asset,\n            items: asset.items.filter((nft) => nft.address !== address),\n          };\n        }\n      });\n    }\n  });\n};\n","import BigNumber from \"bignumber.js\";\nimport BN from \"bn.js\";\n\nexport const formatDecimals = (\n  amount: BigNumber.Value,\n  decimals: number = 9\n): number => {\n  return new BigNumber(amount).div(Math.pow(10, decimals)).toNumber();\n};\n\nexport const formatAmountValue = (\n  amount: BN | string,\n  decimals: number | string = 9\n): string => {\n  return formatDecimals(\n    amount.toString(),\n    parseInt(String(decimals))\n  ).toString();\n};\n\nexport const toCoinValue = (\n  amount: string | BN,\n  decimals: number | string = 9\n): string => {\n  return new BigNumber(amount.toString())\n    .multipliedBy(Math.pow(10, parseInt(String(decimals))))\n    .toFixed(0);\n};\n","/**\n * Service methods to download jetton data\n * The file should contain pure function to download state via http provider\n *\n * @author: KuznetsovNikita\n * @since: 0.12.0\n */\n\nimport { Address } from \"@ton/core\";\nimport { TonClient } from \"@ton/ton\";\nimport {\n  JettonMinter,\n  JettonMinterContent,\n  JettonMinterData,\n  JettonWallet,\n} from \"ton-wrappers\";\nimport { JettonStateSchema } from \"../entries/asset\";\nimport { JettonWalletData } from \"./assetService\";\n\nexport interface JettonFullData {\n  data: JettonMinterData;\n  wallet: JettonWalletData | null;\n  name: JettonMinterContent | null;\n}\n\nexport const getJettonFullData = async (\n  client: TonClient,\n  walletAddress: string,\n  jettonMinterAddress: string\n): Promise<JettonFullData> => {\n  const minterAddress = Address.parse(jettonMinterAddress);\n\n  const minter = client.open(JettonMinter.createFromAddress(minterAddress));\n\n  const data = await minter.getJettonData();\n\n  const name = await JettonStateSchema.validateAsync(data.jettonContent);\n\n  const jettonWalletAddress = await minter.getWalletAddress(\n    Address.parse(walletAddress)\n  );\n\n  const wallet = await getJettonWalletData(\n    client,\n    jettonWalletAddress,\n    minterAddress\n  ).catch((e) => null);\n\n  return { data, wallet, name };\n};\n\nexport const getJettonWalletData = async (\n  client: TonClient,\n  jettonWalletAddress: Address,\n  jettonMinterAddress: Address\n): Promise<JettonWalletData> => {\n  const jettonWallet = client.open(\n    JettonWallet.createFromAddress(jettonWalletAddress)\n  );\n\n  const data = await jettonWallet.getData();\n\n  if (!data.jettonMinterAddress) {\n    throw new Error(\"Missing jetton minter address.\");\n  }\n  if (\n    data.jettonMinterAddress.toRawString() !== jettonMinterAddress.toRawString()\n  ) {\n    throw new Error(\"Jetton minter address not match.\");\n  }\n\n  return {\n    balance: data.balance.toString(),\n    address: jettonWalletAddress.toString(),\n  };\n};\n","import { FC, PropsWithChildren, useContext } from \"react\";\nimport { WalletState } from \"../libs/entries/wallet\";\nimport { FingerprintIcon, UsbIcon } from \"./components/Icons\";\nimport { WalletStateContext } from \"./context\";\nimport { useAuthConfiguration } from \"./screen/settings/api\";\n\nexport const FingerprintWalletLabel: FC<\n  PropsWithChildren<{ wallet: WalletState; isSignature?: boolean }>\n> = ({ children, wallet, isSignature = true }) => {\n  const { data } = useAuthConfiguration();\n  const isWebAuth = data?.kind == \"webauthn\";\n\n  if (!isSignature) {\n    return <>{children}</>;\n  }\n\n  if (wallet.ledger) {\n    return (\n      <>\n        {children} <UsbIcon />\n      </>\n    );\n  }\n\n  if (!isWebAuth && isSignature) {\n    return <>{children}</>;\n  }\n\n  return (\n    <>\n      {children} <FingerprintIcon />\n    </>\n  );\n};\n\nexport const FingerprintLabel: FC<PropsWithChildren> = ({ children }) => {\n  const wallet = useContext(WalletStateContext);\n\n  return (\n    <FingerprintWalletLabel wallet={wallet}>{children}</FingerprintWalletLabel>\n  );\n};\n","import React, { FC } from \"react\";\nimport styled from \"styled-components\";\nimport { ArrowRightIcon } from \"./Icons\";\n\nconst Block = styled.div`\n  padding: 5px 10px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: ${(props) => props.theme.padding};\n  font-size: medium;\n  border: 1px solid ${(props) => props.theme.darkGray};\n`;\n\nconst Icon = styled.span`\n  font-size: large;\n  margin: 0 10px;\n`;\n\nconst Item = styled.div`\n  min-width: 80px;\n  word-break: break-all;\n`;\n\ntype Props = {\n  left: string | null;\n  right: string | null;\n};\n\nexport const AddressTransfer: FC<Props> = React.memo(({ left, right }) => {\n  return (\n    <Block>\n      <Item>{left}</Item>\n      <Icon>\n        <ArrowRightIcon />\n      </Icon>\n      <Item>{right}</Item>\n    </Block>\n  );\n});\n","import { FC } from \"react\";\nimport ExtensionPlatform from \"../../libs/service/extension\";\nimport { useCopyToClipboard } from \"../hooks/useCopyToClipbpard\";\nimport { useSelectedNetworkConfig } from \"../screen/home/api\";\nimport { toShortAddress } from \"../utils\";\nimport { ButtonNegative, InlineLink, Text } from \"./Components\";\nimport { CheckIcon, CopyIcon, LinkIcon } from \"./Icons\";\n\nexport interface AddressBlockProps {\n  label: string;\n  address?: string;\n}\n\nconst AddressLine: FC<{ address: string }> = ({ address }) => {\n  const [copied, handleCopy] = useCopyToClipboard();\n\n  return (\n    <ButtonNegative onClick={() => handleCopy(address)}>\n      {toShortAddress(address)} {copied ? <CheckIcon /> : <CopyIcon />}\n    </ButtonNegative>\n  );\n};\n\nexport const AddressBlock: FC<AddressBlockProps> = ({ label, address }) => {\n  const config = useSelectedNetworkConfig();\n\n  return (\n    <>\n      <Text>\n        <b>{label}</b>{\" \"}\n        {address && (\n          <InlineLink\n            onClick={() =>\n              ExtensionPlatform.openTab({\n                url: `${config.scanUrl}${address}`,\n              })\n            }\n          >\n            Open explorer <LinkIcon />\n          </InlineLink>\n        )}\n      </Text>\n      <Text>\n        {address ? (\n          <AddressLine address={address} />\n        ) : (\n          \"Wallet Address Not Define\"\n        )}\n      </Text>\n    </>\n  );\n};\n","import React, { FC, PropsWithChildren } from \"react\";\nimport styled from \"styled-components\";\n\nconst Label = styled.div`\n  margin: ${(props) => props.theme.padding} 0 5px;\n`;\n\nconst Code = styled.div`\n  padding: 10px;\n  background: ${(props) => props.theme.lightGray};\n  font-size: medium;\n  margin-bottom: ${(props) => props.theme.padding};\n  word-break: break-all;\n`;\n\ninterface Props extends PropsWithChildren {\n  label?: string;\n}\n\nexport const CodeBlock: FC<Props> = React.memo(({ label, children }) => {\n  return (\n    <>\n      {label && <Label>{label}</Label>}\n      <Code>{children}</Code>\n    </>\n  );\n});\n","import React, { FC, useMemo } from \"react\";\nimport styled from \"styled-components\";\nimport { JettonMinterContent } from \"ton-wrappers\";\nimport { ipfsProxy } from \"../../libs/service/requestService\";\nimport { formatAmountValue } from \"../../libs/state/decimalsService\";\nimport { IconSize } from \"./Components\";\nimport { BaseLogoIcon } from \"./Icons\";\n\nconst Row = styled.div`\n  display: inline-flex;\n  gap: ${(props) => props.theme.padding};\n  align-items: center;\n  padding-bottom: ${(props) => props.theme.padding};\n`;\n\nconst Font = styled.span`\n  font-size: large;\n  overflow: hidden;\n  text-overflow: ellipsis;\n`;\n\ninterface Props {\n  state: JettonMinterContent;\n  balance: string | undefined;\n}\n\nexport const JettonRow: FC<Props> = React.memo(({ state, balance }) => {\n  const amount = useMemo(() => {\n    if (!balance) return \"0\";\n    return formatAmountValue(balance, state.decimals);\n  }, [state, balance]);\n\n  return (\n    <Row>\n      <JettonLogo image={state.image} />\n      <Font>\n        {state.name} ({amount} {state.symbol})\n      </Font>\n    </Row>\n  );\n});\n\nconst Image = styled.img`\n  // border-radius: 50%;\n`;\n\nexport const JettonLogo: FC<{ image?: string; size?: number }> = React.memo(\n  ({ image, size = 35 }) => {\n    return image ? (\n      <Image\n        alt=\"Jetton Logo\"\n        width={size + \"px\"}\n        height={size + \"px\"}\n        src={ipfsProxy(image)}\n      />\n    ) : (\n      <IconSize>\n        <BaseLogoIcon />\n      </IconSize>\n    );\n  }\n);\n","import React, { FC } from \"react\";\nimport styled from \"styled-components\";\nimport { NftItemState } from \"../../libs/entries/asset\";\nimport { ipfsProxy } from \"../../libs/service/requestService\";\nimport { Text } from \"./Components\";\n\nconst Block = styled.div`\n  padding: 0 0 ${(props) => props.theme.padding} 0;\n`;\n\nconst ImageWrapper = styled.div`\n  padding: ${(props) => props.theme.padding};\n  margin-bottom: ${(props) => props.theme.padding};\n  border: 1px solid ${(props) => props.theme.darkGray};\n  border-radius: 20px;\n  text-align: center;\n`;\n\nconst NftImage = styled.img`\n  max-height: 200px;\n  max-width: 100%;\n`;\n\nconst Domain = styled.span`\n  font-size: large;\n  font-weight: bold;\n  display: inline-block;\n  margin: ${(props) => props.theme.padding} 0;\n`;\n\nexport const NftPayload: FC<{ state?: NftItemState | null }> = React.memo(\n  ({ state }) => {\n    if (!state) {\n      return (\n        <Block>\n          <Text>Missing NFT content</Text>\n        </Block>\n      );\n    }\n\n    if (\"domain\" in state) {\n      return (\n        <Block>\n          {state.name && (\n            <Text>\n              <b>{state.name}</b>\n            </Text>\n          )}\n          <ImageWrapper>\n            <Domain>\n              {state.domain}.{state.root}\n            </Domain>\n          </ImageWrapper>\n        </Block>\n      );\n    }\n\n    return (\n      <Block>\n        {state.name && (\n          <Text>\n            <b>{state.name}</b>\n          </Text>\n        )}\n        <ImageWrapper>\n          <NftImage src={ipfsProxy(state.image)} alt=\"NFT image\" />\n        </ImageWrapper>\n        {state.description && <Text>{state.description}</Text>}\n      </Block>\n    );\n  }\n);\n","import { fromNano } from \"@openproduct/web-sdk\";\nimport { FC } from \"react\";\nimport { EstimateFeeValues } from \"../../../libs/entries/tonCenter\";\nimport { fiatFees } from \"../../utils\";\nimport { TextLine } from \"../Components\";\nimport { Dots } from \"../Dots\";\n\nexport const Fees: FC<{ estimation?: EstimateFeeValues }> = ({\n  estimation,\n}) => {\n  if (!estimation) {\n    return (\n      <>\n        <TextLine>Network fee estimation:</TextLine>\n        <TextLine>\n          <Dots>Loading</Dots>\n        </TextLine>\n      </>\n    );\n  }\n  const totalTon = fromNano(\n    String(\n      estimation.fwd_fee +\n        estimation.in_fwd_fee +\n        estimation.storage_fee +\n        estimation.gas_fee\n    )\n  );\n\n  return (\n    <>\n      <TextLine>Network fee estimation:</TextLine>\n      <TextLine>\n        ~<b>{fiatFees.format(parseFloat(totalTon))} ION</b>\n      </TextLine>\n    </>\n  );\n};\n","import { useCallback, useEffect, useRef, useState } from \"react\";\n\n/**\n * useTimeout\n *\n * @param {Function} cb - callback function inside setTimeout\n * @param {number} delay - delay in ms\n * @param {boolean} [immediate] - determines whether the timeout is invoked immediately\n * @returns {Function|undefined}\n */\nexport function useTimeout(cb: () => void, delay: number, immediate = true) {\n  const saveCb = useRef<() => void>();\n  const [timeoutId, setTimeoutId] = useState<NodeJS.Timeout | null | \"start\">(\n    null\n  );\n\n  useEffect(() => {\n    saveCb.current = cb;\n  }, [cb]);\n\n  useEffect(() => {\n    if (timeoutId !== \"start\") {\n      return undefined;\n    }\n\n    const id = setTimeout(() => {\n      saveCb.current && saveCb.current();\n    }, delay);\n\n    setTimeoutId(id);\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [delay, timeoutId]);\n\n  const startTimeout = useCallback(() => {\n    typeof timeoutId === \"number\" && clearTimeout(timeoutId);\n    setTimeoutId(\"start\");\n  }, [timeoutId]);\n\n  if (immediate) {\n    startTimeout();\n  }\n\n  return startTimeout;\n}\n","import copyToClipboard from \"copy-to-clipboard\";\nimport { useCallback, useState } from \"react\";\nimport { useTimeout } from \"./useTimeout\";\n\n/**\n * useCopyToClipboard\n *\n * @param {number} [delay=2000] - delay in ms\n * @returns {[boolean, Function]}\n */\nconst DEFAULT_DELAY = 1000 * 2;\n\nexport function useCopyToClipboard(delay = DEFAULT_DELAY) {\n  const [copied, setCopied] = useState(false);\n  const startTimeout = useTimeout(() => setCopied(false), delay, false);\n\n  const handleCopy = useCallback(\n    (text: string) => {\n      setCopied(true);\n      startTimeout();\n      copyToClipboard(text);\n    },\n    [startTimeout]\n  );\n\n  return [copied, handleCopy] as const;\n}\n","import {\n  Address,\n  Cell,\n  NftCollectionDao,\n  NftContentDao,\n  NftData,\n} from \"@openproduct/web-sdk\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { Cell as CoreCell } from \"@ton/core\";\nimport { useContext } from \"react\";\nimport { requestJson } from \"ton-wrappers\";\nimport { readOnchainMetadata } from \"ton-wrappers/dist/libs/onchainContent\";\nimport {\n  DomainNftState,\n  NftCollectionState,\n  NftCollectionStateSchema,\n  NftItemState,\n  NftItemStateSchema,\n} from \"../../../../../../libs/entries/asset\";\nimport {\n  AddJettonProps,\n  AddNftProps,\n  addJettonToWallet,\n  addNftToWallet,\n} from \"../../../../../../libs/state/assetService\";\nimport {\n  JettonFullData,\n  getJettonFullData,\n} from \"../../../../../../libs/state/jettonService\";\nimport {\n  AccountStateContext,\n  NetworkContext,\n  TonClientContext,\n  TonProviderContext,\n  WalletStateContext,\n} from \"../../../../../context\";\nimport { saveAccountState } from \"../../../../api\";\n\nexport const useJettonFullData = () => {\n  const client = useContext(TonClientContext);\n  const wallet = useContext(WalletStateContext);\n  return useMutation<JettonFullData, Error, string>(\n    (jettonMinterAddress: string) => {\n      return getJettonFullData(client, wallet.address, jettonMinterAddress);\n    }\n  );\n};\n\nexport const useAddJettonMutation = () => {\n  const network = useContext(NetworkContext);\n  const account = useContext(AccountStateContext);\n  const client = useQueryClient();\n\n  return useMutation<void, Error, AddJettonProps>(async (options) => {\n    const value = addJettonToWallet(account, options);\n    await saveAccountState(network, client, value);\n  });\n};\n\nexport const useNftDataMutation = () => {\n  const provider = useContext(TonProviderContext);\n  return useMutation<NftData, Error, string>(async (nftAddress) => {\n    const address = new Address(nftAddress);\n    const dao = new NftContentDao(provider, address);\n    return await dao.getData();\n  });\n};\n\nexport const useNftContentMutation = () => {\n  return useMutation<NftItemState, Error, NftData>(\n    async ({ contentUri, contentCell }) => {\n      if (contentUri) {\n        const state = await requestJson<NftItemState>(contentUri);\n        return await NftItemStateSchema.validateAsync(state);\n      } else {\n        const state = readOnchainMetadata(\n          CoreCell.fromBase64(contentCell.toBase64()),\n          [\"image\", \"name\", \"description\"]\n        );\n        return await NftItemStateSchema.validateAsync(state);\n      }\n    }\n  );\n};\n\nexport const useNftCollectionDataMutation = () => {\n  const provider = useContext(TonProviderContext);\n  return useMutation<NftCollectionState, Error, Address>(async (address) => {\n    const dao = new NftCollectionDao(provider, address);\n    const data = await dao.getCollectionData();\n\n    if (data.collectionContentUri) {\n      const state = await requestJson<NftCollectionState>(\n        data.collectionContentUri\n      );\n      return await NftCollectionStateSchema.validateAsync(state);\n    } else if (data.collectionContentCell) {\n      const state = readOnchainMetadata<NftCollectionState>(\n        CoreCell.fromBase64(data.collectionContentCell.toBase64()),\n        [\"image\", \"name\", \"description\"]\n      );\n      return await NftCollectionStateSchema.validateAsync(state);\n    }\n    throw new Error(\"Missing collection content\");\n  });\n};\n\nexport const useAddNftMutation = () => {\n  const network = useContext(NetworkContext);\n  const account = useContext(AccountStateContext);\n  const client = useQueryClient();\n\n  return useMutation<void, Error, AddNftProps>(async (options) => {\n    const value = addNftToWallet(account, options);\n    await saveAccountState(network, client, value);\n  });\n};\n\ninterface DomainNftProps {\n  collection: NftCollectionState;\n  address: string;\n}\nexport const useDomainNftMutation = () => {\n  const provider = useContext(TonProviderContext);\n\n  return useMutation<NftItemState | undefined, Error, DomainNftProps>(\n    async ({ collection, address }) => {\n      if (collection.name === \"ION DNS Domains\") {\n        /**\n         * https://github.com/ton-blockchain/dns-contract/blob/8864d3f6e1743910dc6ec6708540806283df09c4/func/nft-item.fc#L280\n         */\n        const result: Cell = await provider.call2(address, \"get_domain\");\n\n        const nft: DomainNftState = {\n          name: collection.name,\n          root: \"ton\",\n          domain: Buffer.from(result.bits.array).toString(),\n        };\n        return nft;\n      }\n\n      return undefined;\n    }\n  );\n};\n","import { Address, toNano, TonDns, TonHttpProvider } from \"@openproduct/web-sdk\";\nimport { useMutation, useQuery } from \"@tanstack/react-query\";\nimport { Address as CoreAddress } from \"@ton/core\";\nimport { TonClient } from \"@ton/ton\";\nimport { useContext } from \"react\";\nimport { NetworkConfig } from \"../../../../../libs/entries/network\";\nimport { EstimateFeeValues } from \"../../../../../libs/entries/tonCenter\";\nimport { WalletState } from \"../../../../../libs/entries/wallet\";\nimport { getWalletContract } from \"../../../../../libs/service/transfer/core\";\nimport {\n  getEstimatePayload,\n  getPayload,\n} from \"../../../../../libs/service/transfer/payload\";\nimport { validateAddressRestrictions } from \"../../../../../libs/service/transfer/restrictionService\";\nimport {\n  createLedgerTonTransfer,\n  createTonTransfer,\n  TransactionState,\n} from \"../../../../../libs/service/transfer/tonService\";\nimport { QueryType } from \"../../../../../libs/store/browserStore\";\nimport {\n  TonClientContext,\n  TonProviderContext,\n  WalletStateContext,\n} from \"../../../../context\";\nimport { checkBalanceOrDie, getWalletKeyPair } from \"../../../api\";\nimport { signLedgerTransaction } from \"../../../ledger/api\";\nimport { useSelectedNetworkConfig } from \"../../api\";\n\nexport const toState = (searchParams: URLSearchParams): TransactionState => {\n  return {\n    address: decodeURIComponent(searchParams.get(\"address\") ?? \"\"),\n    amount: decodeURIComponent(searchParams.get(\"amount\") ?? \"\"),\n    max: searchParams.get(\"max\") ?? \"\",\n    data: decodeURIComponent(searchParams.get(\"data\") ?? \"\"),\n    isEncrypt: searchParams.get(\"isEncrypt\") === \"1\",\n  };\n};\n\nexport const stateToSearch = (state: TransactionState) => {\n  return Object.entries(state).reduce((acc, [key, value]) => {\n    if (typeof value === \"boolean\" && value) {\n      acc[key] = \"1\";\n    }\n    if (typeof value !== \"boolean\") {\n      acc[key] = encodeURIComponent(value);\n    }\n    return acc;\n  }, {} as Record<string, string>);\n};\n\nexport const getToAddress = async (\n  ton: TonHttpProvider,\n  config: NetworkConfig,\n  toAddress: string\n) => {\n  if (Address.isValid(toAddress)) {\n    return toAddress;\n  }\n  toAddress = toAddress.toLowerCase();\n\n  if (toAddress.endsWith(\".ton\") || toAddress.endsWith(\".t.me\")) {\n    const dns = new TonDns(ton, { rootDnsAddress: config.rootDnsAddress });\n    const address = await dns.getWalletAddress(toAddress);\n    if (!address) {\n      throw new Error(\"Invalid address\");\n    }\n    if (!Address.isValid(address)) {\n      throw new Error(\"Invalid address\");\n    }\n    return new Address(address).toString(true, true, true);\n  } else {\n    throw new Error(\"Invalid address\");\n  }\n};\n\nexport const useTargetAddress = (address: string) => {\n  const client = useContext(TonClientContext);\n  const ton = useContext(TonProviderContext);\n  const config = useSelectedNetworkConfig();\n\n  return useQuery<string, Error>([QueryType.address, address], async () => {\n    const value = await getToAddress(ton, config, address);\n    const coreAddress = CoreAddress.parse(value);\n    const deployed = await client.isContractDeployed(coreAddress);\n    return coreAddress.toString({ urlSafe: true, bounceable: deployed });\n  });\n};\n\nexport const useEstimateTransaction = (\n  state?: TransactionState,\n  address?: string\n) => {\n  const tonClient = useContext(TonClientContext);\n  const wallet = useContext(WalletStateContext);\n\n  return useQuery<EstimateFeeValues>(\n    [QueryType.estimation, state],\n    async () => {\n      if (!state || !address) {\n        throw new Error(\"missing state\");\n      }\n\n      const payload = await getEstimatePayload(\n        tonClient,\n        address,\n        state.isEncrypt,\n        state.data\n      );\n      const transaction = createTonTransfer(0, wallet, address, state, payload);\n\n      const data = await tonClient.estimateExternalMessageFee(\n        CoreAddress.parse(wallet.address),\n        {\n          body: transaction,\n          initCode: null,\n          initData: null,\n          ignoreSignature: true,\n        }\n      );\n      return data.source_fees as EstimateFeeValues;\n    },\n    { enabled: state != null && address != null }\n  );\n};\n\nconst sendLedgerTransaction = async (\n  tonClient: TonClient,\n  wallet: WalletState,\n  address: string,\n  state: TransactionState\n): Promise<number> => {\n  const contract = getWalletContract(wallet);\n  const tonContract = tonClient.open(contract);\n\n  const balance = await tonContract.getBalance();\n  if (state.max !== \"1\") {\n    await checkBalanceOrDie(balance.toString(), toNano(state.amount));\n  }\n  const seqno = await tonContract.getSeqno();\n\n  const payload = await getPayload(\n    tonClient,\n    address,\n    state.isEncrypt,\n    state.data\n  );\n  const transaction = createLedgerTonTransfer(\n    wallet,\n    seqno,\n    address,\n    state,\n    payload\n  );\n\n  const signed = await signLedgerTransaction(transaction);\n  await tonContract.send(signed);\n\n  return seqno;\n};\n\nconst sendMnemonicTransaction = async (\n  tonClient: TonClient,\n  wallet: WalletState,\n  address: string,\n  state: TransactionState\n) => {\n  await validateAddressRestrictions(address);\n  const keyPair = await getWalletKeyPair(wallet);\n\n  const secretKey = Buffer.from(keyPair.secretKey);\n\n  const contract = getWalletContract(wallet);\n  const tonContract = tonClient.open(contract);\n\n  const balance = await tonContract.getBalance();\n\n  if (state.max !== \"1\") {\n    await checkBalanceOrDie(balance.toString(), toNano(state.amount));\n  }\n\n  const seqno = await tonContract.getSeqno();\n\n  const payload = await getPayload(\n    tonClient,\n    address,\n    state.isEncrypt,\n    state.data,\n    secretKey\n  );\n  const transaction = createTonTransfer(\n    seqno,\n    wallet,\n    address,\n    state,\n    payload,\n    undefined,\n    secretKey\n  );\n\n  await tonContract.send(transaction);\n  return seqno;\n};\n\nexport const useSendTransaction = () => {\n  const tonClient = useContext(TonClientContext);\n  const wallet = useContext(WalletStateContext);\n\n  return useMutation<\n    number,\n    Error,\n    { address: string; state: TransactionState }\n  >(async ({ address, state }) => {\n    if (wallet.ledger) {\n      return sendLedgerTransaction(tonClient, wallet, address, state);\n    } else {\n      return sendMnemonicTransaction(tonClient, wallet, address, state);\n    }\n  });\n};\n"],"names":["JettonStateSchema","Joi","type","required","valid","address","symbol","image","name","decimals","description","unknown","NftItemStateSchema","NftCollectionStateSchema","getWalletAssets","wallet","assets","walletAssets","version","map","item","minterAddress","replace","items","nft","setWalletAssets","newAssets","rest","ifpsProtocol","ipfsProxy","url","startsWith","getWalletContract","publicKey","Buffer","from","WalletContractV2R1","workchain","WalletContractV2R2","WalletContractV3R1","WalletContractV3R2","Error","WalletContractV4","getContractAddress","source","cell","beginCell","storeWritable","storeStateInit","code","data","endCell","Address","hash","getWalletAddress","network","contract","init","toString","urlSafe","bounceable","isBounceable","testOnly","AnyWallet","provider","getState","state","get","res","stack","readNumber","walletPubKeyBN","readBigNumber","walletPubKeyHex","length","jettonTransferForwardAmount","toNano","JettonTransferOpCode","jettonTransferBody","params","storeUint","queryId","storeCoins","jettonAmount","storeAddress","toAddress","responseAddress","storeBit","forwardAmount","storeMaybeBuilder","forwardPayload","parseJettonTransfer","slice","asSlice","loadUint","loadCoins","loadMaybeAddress","customPayload","loadBit","loadRef","remainingBits","asCell","BigInt","amount","destination","responseDestination","getJettonAmount","jetton","parseInt","String","BigNumber","shiftedBy","toFormat","decimalSeparator","groupSeparator","createJettonTransfer","seqno","walletState","recipientAddress","jettonWalletAddress","secretKey","alloc","body","Date","now","transfer","createTransfer","sendMode","SendMode","messages","internal","to","bounce","value","transactionAmount","createLedgerJettonTransfer","walletContract","createLedgerJettonTransferPayload","stateInit","payload","timeout","Math","floor","NftTransferOpCode","nftTransferBody","newOwnerAddress","parseNftTransfer","newOwner","createNftTransfer","createLedgerNftTransfer","createLedgerNftTransferPayload","getWalletPublicKey","tonClient","open","getPublicKey","writeBuffer","src","builder","bytes","availableBits","a","subarray","t","storeBuffer","bb","storeRef","encryptedComment","sharedKey","nonce","randomBytes","nacl","encrypted","TextEncoder","encode","concat","getEstimatePayload","isEncrypt","undefined","receiverPublicKey","getSharedSecret","getPayload","getRestrictions","getCachedStoreValue","QueryType","fetch","response","status","statusText","json","setCachedStoreValue","console","log","origin","validateAddressRestrictions","forEach","equals","validateTonConnectRestrictions","restrictions","o","getTonSendMode","max","seeIfBounceable","createTonTransfer","comment","toStateInit","initSlice","Cell","createTonConnectTransfer","fromNano","createLedgerTonTransfer","text","seeIfJettonAsset","asset","useActiveAssets","account","wallets","activeWallet","addJettonToWallet","minter","jettonState","jettonWallet","some","walletAddress","deleteJettonAsset","jettonMinterAddress","filter","setIfNftAssetOver","collectionAddress","addNftToWallet","nftAddress","nftData","collection","nftItemState","contentUri","collectionAsset","find","push","deleteNftAsset","formatDecimals","div","pow","toNumber","formatAmountValue","toCoinValue","multipliedBy","toFixed","getJettonFullData","client","JettonMinter","getJettonData","jettonContent","getJettonWalletData","catch","e","JettonWallet","getData","toRawString","balance","FingerprintWalletLabel","children","isSignature","useAuthConfiguration","isWebAuth","kind","ledger","FingerprintLabel","useContext","WalletStateContext","Block","styled","props","theme","padding","darkGray","Icon","Item","AddressTransfer","React","left","right","AddressLine","useCopyToClipboard","copied","handleCopy","onClick","toShortAddress","AddressBlock","label","config","useSelectedNetworkConfig","ExtensionPlatform","scanUrl","Label","Code","lightGray","CodeBlock","Row","Font","JettonRow","useMemo","JettonLogo","Image","size","alt","width","height","ImageWrapper","NftImage","Domain","NftPayload","domain","root","Fees","estimation","totalTon","fwd_fee","in_fwd_fee","storage_fee","gas_fee","fiatFees","parseFloat","useTimeout","cb","delay","immediate","saveCb","useRef","useState","timeoutId","setTimeoutId","useEffect","current","id","setTimeout","clearTimeout","startTimeout","useCallback","setCopied","copyToClipboard","useJettonFullData","TonClientContext","useMutation","useAddJettonMutation","NetworkContext","AccountStateContext","useQueryClient","options","saveAccountState","useNftDataMutation","TonProviderContext","dao","NftContentDao","useNftContentMutation","contentCell","requestJson","readOnchainMetadata","CoreCell","toBase64","useNftCollectionDataMutation","NftCollectionDao","getCollectionData","collectionContentUri","collectionContentCell","useAddNftMutation","useDomainNftMutation","call2","result","bits","array","toState","searchParams","decodeURIComponent","stateToSearch","Object","entries","reduce","acc","key","encodeURIComponent","getToAddress","ton","toLowerCase","endsWith","dns","TonDns","rootDnsAddress","useTargetAddress","useQuery","coreAddress","CoreAddress","isContractDeployed","deployed","useEstimateTransaction","transaction","estimateExternalMessageFee","initCode","initData","ignoreSignature","source_fees","enabled","sendLedgerTransaction","tonContract","getBalance","checkBalanceOrDie","getSeqno","signLedgerTransaction","signed","send","sendMnemonicTransaction","getWalletKeyPair","keyPair","useSendTransaction"],"sourceRoot":""}